import pytest
from engine.state import GameState, RoomState, PlayerState, DeckState, CardId
from engine.types import RoomId, PlayerId
from engine.actions import Action, ActionType
from engine.transition import step, _consume_action_if_needed
from engine.config import Config
from engine.legality import get_legal_actions
from engine.board import corridor_id, room_id
from engine.boxes import active_deck_for_room

def create_peek_state():
    p1 = PlayerState(player_id=PlayerId("P1"), sanity=5, room=room_id(1, 1)) # Starts in F1_R1
    
    # Setup rooms dictionary BEFORE creating GameState
    rooms = {}
    # F1_R1 (Current)
    rooms[room_id(1, 1)] = RoomState(room_id=room_id(1, 1), deck=DeckState(cards=[CardId("C1")]))
    # F1_R2 (Other room)
    rooms[room_id(1, 2)] = RoomState(room_id=room_id(1, 2), deck=DeckState(cards=[CardId("C2")]))
    # F1_P (Corridor) - Destination
    rooms[corridor_id(1)] = RoomState(room_id=corridor_id(1), deck=DeckState(cards=[]))
    # F2_P (Corridor other floor)
    rooms[corridor_id(2)] = RoomState(room_id=corridor_id(2), deck=DeckState(cards=[]))
    
    s = GameState(round=1, players={PlayerId("P1"): p1}, rooms=rooms)
    
    # Init basic game state fields to allow actions
    s.turn_order = [PlayerId("P1")]
    s.remaining_actions = {PlayerId("P1"): 2}
    s.phase = "PLAYER"
    
    return s

def test_room_to_hallway_triggers_pending_peek():
    """Moving from Room to Hallway (same floor) triggers PENDING_HALLWAY_PEEK."""
    s = create_peek_state()
    cfg = Config()
    
    # Move P1 from F1_R1 to F1_P
    action = Action(actor="P1", type=ActionType.MOVE, data={"to": str(corridor_id(1))})
    s2 = step(s, action, None, cfg)
    
    # Check flag
    assert s2.flags.get("PENDING_HALLWAY_PEEK") == "P1"
    # Check player position updated
    assert s2.players[PlayerId("P1")].room == corridor_id(1)

def test_hallway_to_room_does_not_trigger():
    """Moving from Hallway to Room does NOT trigger PENDING_HALLWAY_PEEK."""
    s = create_peek_state()
    cfg = Config()
    p1 = s.players[PlayerId("P1")]
    p1.room = corridor_id(1) # Start in Hallway
    
    # Move P1 from F1_P to F1_R1
    action = Action(actor="P1", type=ActionType.MOVE, data={"to": str(room_id(1, 1))})
    s2 = step(s, action, None, cfg)
    
    assert s2.flags.get("PENDING_HALLWAY_PEEK") is None

def test_pending_peek_allows_peek_or_skip_only():
    """When pending peek, only PEEK/SKIP actions are legal."""
    s = create_peek_state()
    s.flags["PENDING_HALLWAY_PEEK"] = "P1"
    
    actions = get_legal_actions(s, "P1")
    
    types = [a.type for a in actions]
    assert ActionType.PEEK_ROOM_DECK in types
    assert ActionType.SKIP_PEEK in types
    assert ActionType.MOVE not in types
    assert ActionType.END_TURN not in types

def test_peek_action_resolution():
    """PEEK action reveals card to log and clears flag."""
    s = create_peek_state()
    s.flags["PENDING_HALLWAY_PEEK"] = "P1"
    s.players[PlayerId("P1")].room = corridor_id(1) # Must be on same floor as target
    
    # Peek F1_R2 (Card C2)
    action = Action(actor="P1", type=ActionType.PEEK_ROOM_DECK, data={"room_id": str(room_id(1, 2))})
    cfg = Config()
    s2 = step(s, action, None, cfg)
    
    # Check flag cleared
    assert s2.flags.get("PENDING_HALLWAY_PEEK") is None
    
    # Check log for result
    logs = [entry for entry in s2.action_log if entry.get("event") == "PEEK_RESULT"]
    assert len(logs) == 1
    assert logs[0]["room"] == str(room_id(1, 2))
    assert logs[0]["card"] == "C2" # Deck top card
    
    # Ensure card NOT drawn/removed
    assert s2.rooms[room_id(1, 2)].deck.remaining() == 1
    assert s2.rooms[room_id(1, 2)].deck.top == 0

def test_skip_action_resolution():
    """SKIP action just clears flag."""
    s = create_peek_state()
    s.flags["PENDING_HALLWAY_PEEK"] = "P1"
    
    action = Action(actor="P1", type=ActionType.SKIP_PEEK, data={})
    cfg = Config()
    s2 = step(s, action, None, cfg)
    
    assert s2.flags.get("PENDING_HALLWAY_PEEK") is None

def test_peek_wrong_floor_fails():
    """Cannot peek room on different floor."""
    s = create_peek_state()
    s.flags["PENDING_HALLWAY_PEEK"] = "P1"
    s.players[PlayerId("P1")].room = corridor_id(2) # Player on F2
    
    # Try peek F1_R1
    # Action matches illegal action (not generated by get_legal_actions for this floor)
    action = Action(actor="P1", type=ActionType.PEEK_ROOM_DECK, data={"room_id": str(room_id(1, 1))})
    cfg = Config()
    
    # Expect Illegal action (generic ValueError from step)
    with pytest.raises(ValueError, match="Illegal action"):
        step(s, action, None, cfg)
