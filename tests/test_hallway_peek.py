import pytest
from engine.state_factory import make_game_state
from engine.types import PlayerId
from engine.actions import Action, ActionType
from engine.transition import step
from engine.config import Config
from engine.legality import get_legal_actions
from engine.board import corridor_id, room_id

def create_peek_state():
    rooms = {
        str(room_id(1, 1)): {"cards": ["C1"]},
        str(room_id(1, 2)): {"cards": ["C2"]},
        str(corridor_id(1)): {},
        str(corridor_id(2)): {},
    }
    players = {"P1": {"room": str(room_id(1, 1)), "sanity": 5}}

    s = make_game_state(
        round=1,
        players=players,
        rooms=rooms,
        phase="PLAYER",
        turn_order=["P1"],
        remaining_actions={"P1": 2},
    )
    
    return s

def test_room_to_hallway_triggers_pending_peek():
    """Moving from Room to Hallway (same floor) triggers PENDING_HALLWAY_PEEK."""
    s = create_peek_state()
    cfg = Config()
    
    # Move P1 from F1_R1 to F1_P
    action = Action(actor="P1", type=ActionType.MOVE, data={"to": str(corridor_id(1))})
    s2 = step(s, action, None, cfg)
    
    # Check flag
    assert s2.flags.get("PENDING_HALLWAY_PEEK") == "P1"
    # Check player position updated
    assert s2.players[PlayerId("P1")].room == corridor_id(1)

def test_hallway_to_room_does_not_trigger():
    """Moving from Hallway to Room does NOT trigger PENDING_HALLWAY_PEEK."""
    s = create_peek_state()
    cfg = Config()
    p1 = s.players[PlayerId("P1")]
    p1.room = corridor_id(1) # Start in Hallway
    
    # Move P1 from F1_P to F1_R1
    action = Action(actor="P1", type=ActionType.MOVE, data={"to": str(room_id(1, 1))})
    s2 = step(s, action, None, cfg)
    
    assert s2.flags.get("PENDING_HALLWAY_PEEK") is None

def test_pending_peek_allows_peek_or_skip_only():
    """When pending peek, only PEEK/SKIP actions are legal."""
    s = create_peek_state()
    s.flags["PENDING_HALLWAY_PEEK"] = "P1"
    
    actions = get_legal_actions(s, "P1")
    
    types = [a.type for a in actions]
    assert ActionType.PEEK_ROOM_DECK in types
    assert ActionType.SKIP_PEEK in types
    assert ActionType.MOVE not in types
    assert ActionType.END_TURN not in types

def test_peek_action_resolution():
    """PEEK action reveals card to log and clears flag."""
    s = create_peek_state()
    s.flags["PENDING_HALLWAY_PEEK"] = "P1"
    s.players[PlayerId("P1")].room = corridor_id(1) # Must be on same floor as target
    
    # Peek F1_R2 (Card C2)
    action = Action(actor="P1", type=ActionType.PEEK_ROOM_DECK, data={"room_id": str(room_id(1, 2))})
    cfg = Config()
    s2 = step(s, action, None, cfg)
    
    # Check flag cleared
    assert s2.flags.get("PENDING_HALLWAY_PEEK") is None
    
    # Check log for result
    logs = [entry for entry in s2.action_log if entry.get("event") == "PEEK_RESULT"]
    assert len(logs) == 1
    assert logs[0]["room"] == str(room_id(1, 2))
    assert logs[0]["card"] == "C2" # Deck top card
    
    # Ensure card NOT drawn/removed
    assert s2.rooms[room_id(1, 2)].deck.remaining() == 1
    assert s2.rooms[room_id(1, 2)].deck.top == 0

def test_skip_action_resolution():
    """SKIP action just clears flag."""
    s = create_peek_state()
    s.flags["PENDING_HALLWAY_PEEK"] = "P1"
    
    action = Action(actor="P1", type=ActionType.SKIP_PEEK, data={})
    cfg = Config()
    s2 = step(s, action, None, cfg)
    
    assert s2.flags.get("PENDING_HALLWAY_PEEK") is None

def test_peek_wrong_floor_fails():
    """Cannot peek room on different floor."""
    s = create_peek_state()
    s.flags["PENDING_HALLWAY_PEEK"] = "P1"
    s.players[PlayerId("P1")].room = corridor_id(2) # Player on F2
    
    # Try peek F1_R1
    # Action matches illegal action (not generated by get_legal_actions for this floor)
    action = Action(actor="P1", type=ActionType.PEEK_ROOM_DECK, data={"room_id": str(room_id(1, 1))})
    cfg = Config()
    
    # Expect Illegal action (generic ValueError from step)
    with pytest.raises(ValueError, match="Illegal action"):
        step(s, action, None, cfg)
